From 8be06fd4ee98b40dae8be7a0a87c10ddf7509c90 Mon Sep 17 00:00:00 2001
From: Kas User <kas@example.com>
Date: Wed, 1 Jun 2022 10:48:38 +0000
Subject: [PATCH] iommu: command buffer restored

to version before commit: 266dfcfa6fcfae2a184d0ff840b447308e8e82d0
---
 include/iommu.h |  2 +-
 iommu.c         | 31 ++++++-------------------------
 2 files changed, 7 insertions(+), 26 deletions(-)

diff --git a/include/iommu.h b/include/iommu.h
index 7502079..39222c4 100644
--- a/include/iommu.h
+++ b/include/iommu.h
@@ -156,7 +156,7 @@ typedef struct __packed {
 } iommu_command_t;
 
 extern char event_log[PAGE_SIZE];
-extern iommu_command_t command_buf[2];
+extern iommu_command_t command_buf[PAGE_SIZE / sizeof(iommu_command_t)];
 
 void disable_memory_protection(void);
 
diff --git a/iommu.c b/iommu.c
index fe99a25..6a81884 100644
--- a/iommu.c
+++ b/iommu.c
@@ -25,7 +25,7 @@ iommu_dte_t device_table[2 * PAGE_SIZE / sizeof(iommu_dte_t)] __page_data = {
 		.a = IOMMU_DTE_Q0_V + IOMMU_DTE_Q0_TV,
 	},
 };
-iommu_command_t command_buf[2] __aligned(sizeof(iommu_command_t));
+iommu_command_t command_buf[PAGE_SIZE / sizeof(iommu_command_t)] __page_data;
 char event_log[PAGE_SIZE] __page_data;
 
 #ifdef DEBUG
@@ -182,7 +182,7 @@ static void send_command(u64 *mmio_base, iommu_command_t cmd)
 	u32 cmd_ptr = mmio_base[IOMMU_MMIO_COMMAND_BUF_TAIL] >> 4;
 	command_buf[cmd_ptr++] = cmd;
 	smp_wmb();
-	mmio_base[IOMMU_MMIO_COMMAND_BUF_TAIL] = (cmd_ptr << 4);
+	mmio_base[IOMMU_MMIO_COMMAND_BUF_TAIL] = (cmd_ptr << 4) & 0xfff;
 }
 
 u32 iommu_load_device_table(u32 cap, volatile u64 *completed)
@@ -224,29 +224,10 @@ u32 iommu_load_device_table(u32 cap, volatile u64 *completed)
 	print_u64(mmio_base[IOMMU_MMIO_DEVICE_TABLE_BA]);
 	print("IOMMU_MMIO_DEVICE_TABLE_BA\n");
 
-	/*
-	 * !!! WARNING - HERE BE DRAGONS !!!
-	 *
-	 * Address and size of Command Buffer, reset head and tail registers.
-	 *
-	 * The IOMMU command buffer is required to be an aligned power of two,
-	 * with a minimum size of 4k.  We only need to send a handful of
-	 * commands, and really don't have 4k worth of space to spare.
-	 * Furthermore, the buffer is only ever read by the IOMMU.
-	 *
-	 * Therefore, we have a small array of command buffer entries, aligned
-	 * on the size of one entry.  We program the IOMMU to say that the
-	 * command buffer is 8k long (to cover the case that the array crosses
-	 * a page boundary), and move both the head and tail pointers forwards
-	 * to the start of the buffer.
-	 *
-	 * This will malfunction if more commands are sent than fit in
-	 * command_buf[] to begin with, but we do save almost 4k of space,
-	 * 1/16th of that available to us.
-	 */
-	mmio_base[IOMMU_MMIO_COMMAND_BUF_BA] = (u64)(_u(command_buf) & ~0xfff)| (0x9ULL << 56);
-	mmio_base[IOMMU_MMIO_COMMAND_BUF_HEAD] =
-		mmio_base[IOMMU_MMIO_COMMAND_BUF_TAIL] = _u(command_buf) & 0xff0;
+	/* Address and size of Command Buffer, reset head and tail registers */
+	mmio_base[IOMMU_MMIO_COMMAND_BUF_BA] = (u64)_u(command_buf) | (0x8ULL << 56);
+	mmio_base[IOMMU_MMIO_COMMAND_BUF_HEAD] = 0;
+	mmio_base[IOMMU_MMIO_COMMAND_BUF_TAIL] = 0;
 
 	print_u64(mmio_base[IOMMU_MMIO_COMMAND_BUF_BA]);
 	print("IOMMU_MMIO_COMMAND_BUF_BA\n");
-- 
2.30.2
